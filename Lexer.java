public class Lexer {

    /* Pair
       
       private class to store token / lexeme objects
    */
    private class Pair<t> {
        int token;
        t lexeme;
        public Pair(int tok, t lex) {
            this.token = tok;
            this.lexeme = lex;
        }
        public Pair() {}
        public int getToken() {return this.token;}
        public t getLexeme() {return this.lexeme;}
        public void setToken(int token) {this.token = token;}
        public void setLexeme(t lexeme) {this.lexeme = lexeme;}
    }

    // every possible token generated by the language; 8 - 13 are equality statements
    int STRING = 0,
        ID = 1,
        INT = 2,
        MINUS = 3,
        PLUS = 4,
        MULTI = 5,
        DIVIDE = 6,
        MODULO = 7,
        LT = 8,
        LTE = 9,
        GT = 10,
        GTE = 11,
        EQU = 12,
        NEQU = 13,
        OPENPAR = 14,
        CLOSEPAR = 15,
        SEMICOLON = 16,
        KEYWORD = 17,
        NEWLINE = 18,
        TAB = 19,
        END_OF_INPUT = 20,
        ERROR = 21;

    //keywords that are reserved by the language, cannot be used as IDs    
    String KEYWORDS[] = {"print", "get", "if", "then", "else", "end", "while", "do", "and", "or", "not"};

    int LINE = 1; // keep track of the current input line file
    

    public Lexer() {}

    public void nextLine() {LINE++;}

    /*  lookup
        input: (String) lexeme
        returns: (Pair) token/id

        determines whether a lexeme is a KEYWORD or an ID
    */
    public Pair<String> lookup(String lexeme) {
        Pair<String> pair = new Pair<String>();
        for (int i = 0; i < KEYWORDS.length; i++) {
            if (lexeme == KEYWORDS[i]) {
                pair.setToken(KEYWORD);
                pair.setLexeme(lexeme);
                return pair;
            }
        }
        pair.setToken(ID);
        pair.setLexeme(lexeme);
        return pair;
    }

    /* error
       input: (String) error message
       returns: (Pair) ERROR/error message

       returns an ERROR token along with an error message
    */
    public Pair<String> error(String msg) {
        String err_message = "Error on line " + LINE + ":" + msg; 
        Pair<String> pair = new Pair<String>(ERROR, err_message);
        return pair;
    }


    /* lex_int
       input: (String, char) input, sign
       returns: (Pair) INT/number

       returns an INT token along with its associated integer
    */
    public Pair<Integer> lex_int(String input, char sign) {
        int i = 0;
        String number = "";
        while (i < input.length() && Character.isDigit(input.charAt(i)))
            number += input.charAt(i);
        int integer = Integer.parseInt(number) * sign;
        Pair<Integer> pair = new Pair<Integer>(INT, integer);
        return pair;
    }


    /* keyword_or_id
       input: (String) input
       returns: (Pair) token/id

       determines whether a lexeme should be assigned a KEYWORD token or an ID token
    */
    public Pair<String> keyword_or_id(String input) {
        int i = 0;
        String lexeme = "";
        while (i < input.length() && (Character.isDigit(input.charAt(i)) || Character.isAlphabetic(input.charAt(i)) || input.charAt(i) == '_' )) {
            lexeme += input.charAt(i);
            i++;
        }
        return lookup(lexeme);
    }

    /* lex_string
       input: (String) input
       returns: (Pair) STRING/string

       turns any input between two paranthesese into a STRING token
    */
    public Pair<String> lex_string(String input) {
        int i = 0;
        String string = "";
        while (i < input.length() && input.charAt(i) != '"') {
            i++;
            if (input.charAt(i-1) == '\\') {
                if (i < input.length() && input.charAt(i) == '\\')
                    string += "\\";
                else if (i < input.length() && input.charAt(i) == 't')
                    string += "\t";
                else if (i < input.length() && input.charAt(i) == 'n')
                    string += "\n";
                else if (i < input.length() && input.charAt(i) == '"')
                    string += "\"";
            }
            else {
                string += input.charAt(i);
            }
        }
        Pair<String> pair = new Pair<String>(STRING, string);
        return pair;
    }


    public Pair<?> lex(String input) {
        int i = 0;
        while (i < input.length() && (input.charAt(i) == ' ' || input.charAt(i) == '/')) {
            i++;
        }
        if (i >= input.length()) {
            Pair<String> pair = new Pair<String>(END_OF_INPUT, null);
            return pair;
        }
        if (input.charAt(i) == '+') {
            if (i + 1 < input.length()) {

            }
            else {
                Pair<String> pair = new Pair<String>(ERROR, "Unexpected character '" + input.charAt(i) + "'" + " on line " + LINE);
                return pair;
            }

        }
        return null; // can remove once every return statement has been added
    }
}