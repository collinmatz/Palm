public class Lexer {

    /* Pair
       private class to store token / lexeme objects
    */
    public class Pair<t> {
        int token;
        t lexeme;
        public Pair(int tok, t lex) {
            this.token = tok;
            this.lexeme = lex;
        }
        public Pair() {}
        public int getToken() {return this.token;}
        public t getLexeme() {return this.lexeme;}
        public void setToken(int token) {this.token = token;}
        public void setLexeme(t lexeme) {this.lexeme = lexeme;}
    }

    // every possible token generated by the language; 8 - 13 are equality statements
    int STRING = 0,
        ID = 1,
        INT = 2,
        MINUS = 3,
        PLUS = 4,
        MULTI = 5,
        DIVIDE = 6,
        MODULO = 7,
        LT = 8,
        LTE = 9,
        GT = 10,
        GTE = 11,
        EQU = 12,
        NEQU = 13,
        OPENPAR = 14,
        CLOSEPAR = 15,
        SEMICOLON = 16,
        KEYWORD = 17,
        NEWLINE = 18,
        TAB = 19,
        ASSIGN = 20,
        END_OF_INPUT = 21,
        ERROR = 22;

    //keywords that are reserved by the language, cannot be used as IDs    
    String KEYWORDS[] = {"print", "get", "if", "then", "else", "end", "while", "do", "and", "or", "not", "for"};

    int LINE = 0; // keep track of the current input line file
    

    public Lexer() {}

    public void nextLine() {LINE++;}

    /*  lookup
        input: (String) lexeme
        returns: (Pair) token/id

        determines whether a lexeme is a KEYWORD or an ID
    */
    public Pair<String> lookup(String lexeme) {
        Pair<String> pair = new Pair<String>();
        for (int i = 0; i < KEYWORDS.length; i++) {
            if (lexeme.equals(KEYWORDS[i])) {
                pair.setToken(KEYWORD);
                pair.setLexeme(lexeme);
                return pair;
            }
        }
        pair.setToken(ID);
        pair.setLexeme(lexeme);
        return pair;
    }

    /* error
       input: (String) error message
       returns: (Pair) ERROR/error message

       returns an ERROR token along with an error message
    */
    public Pair<String> error(String msg) {
        String err_message = "Error on line " + LINE + ":" + msg; 
        Pair<String> pair = new Pair<String>(ERROR, err_message);
        return pair;
    }


    /* lex_int
       input: (String, char) input, sign
       returns: (Pair) INT/number

       returns an INT token along with its associated integer
    */
    public Pair<Integer> lex_int(String input, int sign) {
        int i = 0;
        String number = "";
        while (i < input.length() && Character.isDigit(input.charAt(i)))
        {
            number += input.charAt(i);
            i++;
        }
        int integer = Integer.parseInt(number) * sign;
        Pair<Integer> pair = new Pair<Integer>(INT, integer);
        return pair;
    }


    /* keyword_or_id
       input: (String) input
       returns: (Pair) token/id

       determines whether a lexeme should be assigned a KEYWORD token or an ID token
    */
    public Pair<String> keyword_or_id(String input) {
        int i = 0;
        String lexeme = "";
        while (i < input.length() && (Character.isDigit(input.charAt(i)) || Character.isAlphabetic(input.charAt(i)) || input.charAt(i) == '_' )) {
            lexeme += input.charAt(i);
            i++;
        }
        return lookup(lexeme);
    }

    /* lex_string
       input: (String) input
       returns: (Pair) string/string

       turns any input between two paranthesese into a STRING token
    */
    public Pair<String> lex_string(String input) {
        int i = 0;
        String string = "";
        while (i < input.length() && input.charAt(i) != '"') {
            i++;
            if (input.charAt(i-1) == '\\') {
                if (i < input.length() && input.charAt(i) == '\\')
                    string += "\\";
                else if (i < input.length() && input.charAt(i) == 't')
                    string += "\t";
                else if (i < input.length() && input.charAt(i) == 'n')
                    string += "\n";
                else if (i < input.length() && input.charAt(i) == '"')
                    string += "\"";
            }
            else {
                string += input.charAt(i);
            }
        }
        Pair<String> pair = new Pair<String>(STRING, string);
        return pair;
    }


    /* lex
       input: (String) input
       returns: (Pair) string/string

       turns any input between two paranthesese into a STRING token
    */
    public Pair<?> lex(String input) {
        nextLine();
        int i = 0;
        while (i < input.length() && (input.charAt(i) == ' ')) {
            i++;
        }

        if (i >= input.length())
            return new Pair<String>(END_OF_INPUT, null);
        
        if (input.charAt(i) == '+') {
            i++;
            if (i < input.length()) {
                if (Character.isDigit(input.charAt(i)))
                    return lex_int(input.substring(i), 1);
            }
            return new Pair<String>(PLUS, "+");
        }

        else if (input.charAt(i) == '-') {
            i++;
            if (i < input.length()) {
                if (Character.isDigit(input.charAt(i)))
                    return lex_int(input.substring(i), -1);
            }
            return new Pair<String>(MINUS, "-");
        }

        else if (input.charAt(i) == '*') {
            return new Pair<String>(MULTI, "*");
        }

        else if (input.charAt(i) == '/') {
            i++;
            if (i < input.length()) {
                if (input.charAt(i) == '/')
                    while (i < input.length())
                        i++;
            }
            return new Pair<String>(DIVIDE, "/");
        }

        else if (input.charAt(i) == '%') {
            return new Pair<String>(MODULO, "%");
        }

        else if (input.charAt(i) == '<') {
            i++;
            if (i < input.length()) {
                if (input.charAt(i) == '=')
                    return new Pair<String>(LTE, "<=");
            }
            return new Pair<String>(LT, "<");
        }

        else if (input.charAt(i) == '>') {
            i++;
            if (i < input.length()) {
                if (input.charAt(i) == '=')
                    return new Pair<String>(GTE, ">=");
            }
            return new Pair<String>(GT, ">");
        }

        else if (input.charAt(i) == '=') {
            i++;
            if (i < input.length()) {
                if (input.charAt(i) == '=')
                    return new Pair<String>(EQU, "==");
            }
            return new Pair<String>(ASSIGN, "=");
        }

        else if (input.charAt(i) == '!') {
            i++;
            if (i < input.length()) {
                if (input.charAt(i) == '=')
                    return new Pair<String> (NEQU, "!=");
            }
            return error("Unexcpeted Character");
        }

        else if (input.charAt(i) == '(') {
            return new Pair<String>(OPENPAR, "(");
        }

        else if (input.charAt(i) == ')') {
            return new Pair<String>(CLOSEPAR, ")");
        }

        else if (input.charAt(i) == ';') {
            return new Pair<String>(SEMICOLON, ";");
        }

        else if (input.charAt(i) == '_' || Character.isAlphabetic(input.charAt(i))) {
            return keyword_or_id(input.substring(i));
        }

        else if (Character.isDigit(input.charAt(i))) {
            return lex_int(input.substring(i), 1);
        }

        else if (input.charAt(i) == '"') {
            return lex_string(input.substring(i));
        }

        else if (input.charAt(i) == '\n') {
            nextLine();
            return new Pair<String>(NEWLINE, "\\n");
        }

        return error("Unexpected Character");
    }
}